[
  {
    "ruleId": "",
    "ruleTitle": "Lazy Load Non-Critical Modules",
    "type": "bad",
    "code": "// app.module.ts\nimport { Module } from '@nestjs/common';\nimport { UsersModule } from './users/users.module';\nimport { AdminModule } from './admin/admin.module';\nimport { AnalyticsModule } from './analytics/analytics.module';\nimport { ReportsModule } from './reports/reports.module';\n\n@Module({\n  imports: [\n    CoreModule,\n    UsersModule,\n    AdminModule,      // üö® Always loads at startup\n    AnalyticsModule,  // üö® Always loads at startup\n    ReportsModule,    // üö® Always loads at startup\n  ],\n})\nexport class AppModule {}",
    "language": "typescript",
    "description": "Incorrect example for Lazy Load Non-Critical Modules"
  },
  {
    "ruleId": "",
    "ruleTitle": "Lazy Load Non-Critical Modules",
    "type": "good",
    "code": "# Application startup\n[AppModule] initialized\n[UsersModule] initialized\n\nStartup time: 0.5s\nMemory usage: 100MB\n\n# After first admin request\n[AdminModule] loaded\nMemory usage: 150MB (+50MB)\n\n# After first analytics request\n[AnalyticsModule] loaded\nMemory usage: 230MB (+80MB)",
    "language": "bash",
    "description": "Correct example for Lazy Load Non-Critical Modules"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use @nestjs/schedule for Cron Jobs and Scheduled Tasks",
    "type": "bad",
    "code": "// cleanup.service.ts - Raw timers üö®\nimport { Injectable, OnModuleDestroy } from '@nestjs/common';\n\n@Injectable()\nexport class CleanupService implements OnModuleDestroy {\n  private intervals: NodeJS.Timeout[] = [];\n\n  constructor() {\n    // ‚ùå Raw interval - no NestJS lifecycle\n    const interval1 = setInterval(() => {\n      this.cleanupExpiredSessions().catch(console.error);\n    }, 60000);  // Every minute\n\n    // ‚ùå Another raw interval\n    const interval2 = setInterval(() => {\n      this.deleteOldLogs().catch(console.error);\n    }, 3600000);  // Every hour\n\n    // ‚ùå Manual interval tracking\n    this.intervals.push(interval1, interval2);\n  }\n\n  // ‚ùå Manual cleanup required\n  onModuleDestroy() {\n    this.intervals.forEach(clearInterval);\n  }\n\n  // ‚ùå No error handling in callbacks\n  async cleanupExpiredSessions() {\n    await this.prisma.session.deleteMany({\n      where: { expiresAt: { lt: new Date() } },\n    });\n  }\n\n  async deleteOldLogs() {\n    await this.prisma.log.deleteMany({\n      where: { createdAt: { lt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } },\n    });\n  }\n}\n\n// subscription.service.ts - Manual tracking üö®\n@Injectable()\nexport class SubscriptionService {\n  private checkInterval: NodeJS.Timeout;\n\n  constructor(private prisma: PrismaService) {\n    // ‚ùå Manually start interval\n    this.startCheckingExpiringSubscriptions();\n  }\n\n  private startCheckingExpiringSubscriptions() {\n    this.checkInterval = setInterval(async () => {\n      try {\n        await this.checkExpiringSubscriptions();\n      } catch (error) {\n        console.error('Subscription check failed:', error);\n        // ‚ùå No structured logging\n      }\n    }, 24 * 60 * 60 * 1000);  // Daily\n  }\n\n  private async checkExpiringSubscriptions() {\n    // Business logic\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Use @nestjs/schedule for Cron Jobs and Scheduled Tasks"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use @nestjs/schedule for Cron Jobs and Scheduled Tasks",
    "type": "good",
    "code": "// tasks/scheduled-tasks.service.spec.ts ‚úÖ\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { ScheduledTasksService } from './scheduled-tasks.service';\nimport { SchedulerRegistry } from '@nestjs/schedule';\n\ndescribe('ScheduledTasksService', () => {\n  let service: ScheduledTasksService;\n  let schedulerRegistry: SchedulerRegistry;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        ScheduledTasksService,\n        {\n          provide: PrismaService,\n          useValue: { session: { deleteMany: jest.fn() } },\n        },\n        {\n          provide: SchedulerRegistry,\n          useValue: {\n            addCronJob: jest.fn(),\n            getCronJob: jest.fn(),\n            deleteCronJob: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n\n    service = module.get<ScheduledTasksService>(ScheduledTasksService);\n    schedulerRegistry = module.get<SchedulerRegistry>(SchedulerRegistry);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  it('should cleanup expired sessions', async () => {\n    const deleteMany = jest.fn().mockResolvedValue({ count: 5 });\n    service['prisma'].session.deleteMany = deleteMany;\n\n    await service.cleanupExpiredSessions();\n\n    expect(deleteMany).toHaveBeenCalledWith({\n      where: { expiresAt: { lt: expect.any(Date) } },\n    });\n  });\n\n  it('should handle errors gracefully', async () => {\n    const loggerSpy = jest.spyOn(service['logger'], 'error');\n    jest.spyOn(service['prisma'].session, 'deleteMany').mockRejectedValue(\n      new Error('Database error')\n    );\n\n    await service.cleanupExpiredSessions();\n\n    expect(loggerSpy).toHaveBeenCalled();\n  });\n});",
    "language": "typescript",
    "description": "Correct example for Use @nestjs/schedule for Cron Jobs and Scheduled Tasks"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Cursor-Based Pagination for Large Datasets",
    "type": "bad",
    "code": "// dto/get-users.dto.ts - Offset pagination üö®\nexport class GetUsersDto {\n  @IsInt()\n  @Min(1)\n  page: number = 1;\n\n  @IsInt()\n  @Min(1)\n  @Max(100)\n  limit: number = 20;\n}\n\n// users.controller.ts - Offset based üö®\n@Controller('users')\nexport class UsersController {\n  @Get()\n  async findAll(@Query() dto: GetUsersDto) {\n    return this.usersService.findAll(dto);\n  }\n}\n\n// users.service.ts - OFFSET scans all rows üö®\n@Injectable()\nexport class UsersService {\n  async findAll(dto: GetUsersDto) {\n    const { page, limit } = dto;\n    const skip = (page - 1) * limit;\n\n    // Page 1000: scans 19,980 rows just to return 20!\n    const [users, total] = await Promise.all([\n      this.prisma.user.findMany({\n        skip,  // ‚ùå Scans and discards rows\n        take: limit,\n        orderBy: { createdAt: 'desc' },\n      }),\n      this.prisma.user.count(),\n    ]);\n\n    return {\n      data: users,\n      meta: {\n        total,\n        page,\n        limit,\n        totalPages: Math.ceil(total / limit),\n      },\n    };\n  }\n}\n\n/* Performance issues:\n * Page 1:    ~1ms    (scans 0 rows)\n * Page 10:   ~5ms    (scans 180 rows)\n * Page 100:  ~50ms   (scans 1,980 rows)\n * Page 1000: ~500ms  (scans 19,980 rows)\n * Page 10000: ~5000ms (scans 199,980 rows)\n */",
    "language": "typescript",
    "description": "Incorrect example for Use Cursor-Based Pagination for Large Datasets"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Cursor-Based Pagination for Large Datasets",
    "type": "good",
    "code": "// components/UserInfiniteScroll.tsx\nimport { useEffect, useRef } from 'react';\nimport { useUsers } from '../hooks/useUsers';\n\nexport function UserInfiniteScroll() {\n  const { users, hasNextPage, loadNext } = useUsers();\n  const observerRef = useRef<IntersectionObserver>();\n\n  const lastUserRef = (node: HTMLLIElement) => {\n    if (observerRef.current) observerRef.current.disconnect();\n\n    observerRef.current = new IntersectionObserver((entries) => {\n      if (entries[0].isIntersecting && hasNextPage) {\n        loadNext();\n      }\n    });\n\n    if (node) observerRef.current.observe(node);\n  };\n\n  return (\n    <ul>\n      {users.map((user, index) => (\n        <li\n          key={user.id}\n          ref={index === users.length - 1 ? lastUserRef : undefined}\n        >\n          {user.name}\n        </li>\n      ))}\n    </ul>\n  );\n}",
    "language": "tsx",
    "description": "Correct example for Use Cursor-Based Pagination for Large Datasets"
  },
  {
    "ruleId": "",
    "ruleTitle": "Generate Swagger/OpenAPI Documentation",
    "type": "bad",
    "code": "// users.controller.ts - Clients must guess schema üö®\n@Controller('users')\nexport class UsersController {\n  @Post()\n  create(@Body() data: any) {\n    return this.usersService.create(data);\n  }\n}",
    "language": "typescript",
    "description": "no documentation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Generate Swagger/OpenAPI Documentation",
    "type": "good",
    "code": "// main.ts\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  const config = new DocumentBuilder()\n    .setTitle('Users API')\n    .setDescription('User management endpoints')\n    .setVersion('1.0')\n    .addBearerAuth()\n    .build();\n    \n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api/docs', app, document);  // ‚úÖ Interactive docs\n  \n  await app.listen(3000);\n}\n\n// users.controller.ts\n@ApiTags('users')\n@ApiBearerAuth()\n@Controller('users')\nexport class UsersController {\n  @Post()\n  @ApiOperation({ summary: 'Create new user' })\n  @ApiResponse({ status: 201, description: 'User created', type: UserDto })\n  @ApiResponse({ status: 400, description: 'Invalid input' })\n  create(@Body() createUserDto: CreateUserDto) {\n    return this.usersService.create(createUserDto);\n  }\n}",
    "language": "typescript",
    "description": "auto-generated docs"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Enum Classes for Type-Safe Values",
    "type": "bad",
    "code": "// tasks/tasks.service.ts - String literals üö®\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class TasksService {\n  // ‚ùå String parameter - any value accepted\n  async updateStatus(id: string, status: string) {\n    const task = await this.repo.findOne(id);\n    task.status = status; // ‚ùå No type safety\n    return this.repo.save(task);\n  }\n\n  // ‚ùå Typo-prone comparisons\n  async getOpenTasks() {\n    // If you type 'opne' instead of 'open', no error!\n    return this.repo.find({ where: { status: 'opne' } });\n  }\n\n  // ‚ùå Magic strings throughout code\n  async completeTask(id: string) {\n    const task = await this.repo.findOne(id);\n    task.status = 'done'; // ‚ùå What if other code uses 'DONE'?\n    return this.repo.save(task);\n  }\n\n  // ‚ùå Inconsistent values\n  async createTask(title: string) {\n    // Is it 'open', 'Open', or 'OPEN'?\n    const task = this.repo.create({ title, status: 'OPEN' });\n    return this.repo.save(task);\n  }\n}\n\n// tasks/dto/create-task.dto.ts üö®\nexport class CreateTaskDto {\n  title: string;\n\n  // ‚ùå No validation of allowed values\n  status?: string;\n}\n\n// tasks/task.entity.ts üö®\nimport { Entity, Column } from 'typeorm';\n\n@Entity()\nexport class Task {\n  @Column({\n    type: 'varchar', // ‚ùå No enum type constraint\n  })\n  status: string; // ‚ùå Any string can be stored\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Enum Classes for Type-Safe Values"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Enum Classes for Type-Safe Values",
    "type": "good",
    "code": "// ‚úÖ Alternative: String union types (for simple cases)\n// tasks/task-status.type.ts\nexport type TaskStatus = 'OPEN' | 'IN_PROGRESS' | 'DONE';\n\n// Still type-safe, but no enum object at runtime\nconst status: TaskStatus = 'OPEN'; // ‚úÖ Valid\nconst invalid: TaskStatus = 'INVALID'; // ‚ùå Compile error\n\n// You can still get all values (requires manual array)\nexport const TASK_STATUSES: TaskStatus[] = ['OPEN', 'IN_PROGRESS', 'DONE'];",
    "language": "typescript",
    "description": "Correct example for Use Enum Classes for Type-Safe Values"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Event-Driven Architecture for Loose Coupling",
    "type": "bad",
    "code": "// users.service.ts - Tight coupling üö®\n@Injectable()\nexport class UsersService {\n  constructor(\n    private prisma: PrismaService,\n    private emailService: EmailService,      // ‚ùå Direct dependency\n    private notificationService: NotificationService,  // ‚ùå Direct dependency\n    private profileService: ProfileService,   // ‚ùå Direct dependency\n    private auditService: AuditService,       // ‚ùå Direct dependency\n    private analyticsService: AnalyticsService,  // ‚ùå Direct dependency\n  ) {}\n\n  async register(data: RegisterDto) {\n    const user = await this.prisma.user.create({ data });\n\n    // ‚ùå Five dependencies just for side effects!\n    await this.emailService.sendVerification(user.email);\n    await this.notificationService.sendPush(user.id, 'Welcome!');\n    await this.profileService.createDefault(user.id);\n    await this.auditService.log('USER_REGISTERED', { userId: user.id });\n    await this.analyticsService.track('user_registered', { userId: user.id });\n\n    // ‚ùå Hard to test - need to mock all 5 services\n    // ‚ùå Hard to maintain - adding new feature requires modifying UsersService\n    // ‚ùå Errors cascade - if email fails, everything fails\n    // ‚ùå Hard to scale - all side effects are synchronous\n  }\n\n  async deleteUser(userId: string) {\n    await this.prisma.user.delete({ where: { id: userId } });\n\n    // ‚ùå Direct calls everywhere\n    await this.notificationService.clearUserNotifications(userId);\n    await this.profileService.delete(userId);\n    await this.analyticsService.deleteUserData(userId);\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Event-Driven Architecture for Loose Coupling"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Event-Driven Architecture for Loose Coupling",
    "type": "good",
    "code": "// users.service.spec.ts ‚úÖ\nimport { EventEmitter2 } from '@nestjs/event-emitter';\n\ndescribe('UsersService', () => {\n  let service: UsersService;\n  let eventEmitter: EventEmitter2;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        UsersService,\n        {\n          provide: PrismaService,\n          useValue: { user: { create: jest.fn() } },\n        },\n        {\n          provide: EventEmitter2,\n          useValue: { emit: jest.fn() },\n        },\n      ],\n    }).compile();\n\n    service = module.get(UsersService);\n    eventEmitter = module.get(EventEmitter2);\n  });\n\n  it('should emit user.registered event on registration', async () => {\n    const mockUser = { id: '1', email: 'test@example.com' };\n    jest.spyOn(service['prisma'].user, 'create').mockResolvedValue(mockUser);\n\n    await service.register({ email: 'test@example.com' });\n\n    expect(eventEmitter.emit).toHaveBeenCalledWith(\n      'user.registered',\n      expect.any(UserRegisteredEvent)\n    );\n  });\n});",
    "language": "typescript",
    "description": "Correct example for Use Event-Driven Architecture for Loose Coupling"
  },
  {
    "ruleId": "",
    "ruleTitle": "Organize Code by Feature Modules",
    "type": "bad",
    "code": "src/\n  users.controller.ts\n  users.service.ts\n  auth.controller.ts\n  auth.service.ts\n  products.controller.ts  // Chaos!\n  products.service.ts\n  orders.controller.ts\n  orders.service.ts",
    "language": "typescript",
    "description": "Incorrect example for Organize Code by Feature Modules"
  },
  {
    "ruleId": "",
    "ruleTitle": "Organize Code by Feature Modules",
    "type": "good",
    "code": "// orders/orders.service.ts\nimport { EventEmitter2 } from '@nestjs/event-emitter';\n\n@Injectable()\nexport class OrdersService {\n  constructor(private eventEmitter: EventEmitter2) {}\n\n  async createOrder(order: CreateOrderDto) {\n    const newOrder = await this.save(order);\n\n    // Emit event, don't directly call other services\n    this.eventEmitter.emit('order.created', { orderId: newOrder.id });\n\n    return newOrder;\n  }\n}\n\n// email/email.service.ts\nimport { OnEvent } from '@nestjs/event-emitter';\n\n@Injectable()\nexport class EmailService {\n  @OnEvent('order.created')\n  async sendOrderConfirmation(payload: { orderId: string }) {\n    await this.sendEmail({\n      to: 'customer@example.com',\n      subject: 'Order Confirmation',\n      body: `Order ${payload.orderId} received`,\n    });\n  }\n}",
    "language": "typescript",
    "description": "Correct example for Organize Code by Feature Modules"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Consistent Naming Conventions",
    "type": "bad",
    "code": "userController.ts      // camelCase file\nUserService.ts         // PascalCase file  \ngetuserById()          // mixed case method\nUserservice            // missing suffix",
    "language": "typescript",
    "description": "mixed conventions"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Consistent Naming Conventions",
    "type": "good",
    "code": "users.controller.ts    // kebab-case file\nusers.service.ts       // kebab-case file\nUsersController        // PascalCase class\nUsersService           // PascalCase class\nfindUserById()         // camelCase method ‚úÖ\ngetUserProfile()       // camelCase method ‚úÖ",
    "language": "typescript",
    "description": "NestJS conventions"
  },
  {
    "ruleId": "",
    "ruleTitle": "Remove Unused Code and Dependencies",
    "type": "bad",
    "code": "// package.json - Unused deps\n{\n  \"dependencies\": {\n    \"lodash\": \"^4.17.20\",     // Never imported\n    \"moment\": \"^2.29.4\",      // Replaced by date-fns\n    \"axios\": \"^1.0.0\"         // Switched to fetch\n  }\n}",
    "language": "json",
    "description": "code rot"
  },
  {
    "ruleId": "",
    "ruleTitle": "Remove Unused Code and Dependencies",
    "type": "good",
    "code": "// package.json - Clean ‚úÖ\n{\n  \"scripts\": {\n    \"cleanup\": \"bun pm prune && bun pm cache rm && bun run lint:fix\",\n    \"depcheck\": \"depcheck && ts-unused-exports tsconfig.json\"\n  }\n}",
    "language": "json",
    "description": "clean codebase"
  },
  {
    "ruleId": "",
    "ruleTitle": "Keep Functions Short and Single Purpose",
    "type": "bad",
    "code": "@Post()\nasync createUser(@Body() data: any) {\n  // 3 responsibilities mixed üö®\n  const hashedPassword = await bcrypt.hash(data.password, 10);\n  const user = await this.prisma.user.create({ data: {...data, password: hashedPassword} });\n  const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET);\n  await this.sendWelcomeEmail(user.email);\n  return { user, token };\n}",
    "language": "typescript",
    "description": "god function"
  },
  {
    "ruleId": "",
    "ruleTitle": "Keep Functions Short and Single Purpose",
    "type": "good",
    "code": "@Post()\nasync createUser(@Body() data: CreateUserDto) {\n  const hashedPassword = await this.hashPassword(data.password);\n  const user = await this.usersRepository.create({ ...data, password: hashedPassword });\n  const token = this.generateToken(user.id);\n  await this.emailService.sendWelcome(user.email);\n  return { user, token };  // ‚úÖ Orchestration only\n}\n\nprivate async hashPassword(password: string) {\n  return bcrypt.hash(password, 10);\n}",
    "language": "typescript",
    "description": "single responsibility"
  },
  {
    "ruleId": "",
    "ruleTitle": "Single Responsibility - Separate Controller and Service",
    "type": "bad",
    "code": "@Controller('orders')\nexport class OrdersController {\n  constructor(private repository: OrdersRepository) {}\n\n  @Post()\n  async createOrder(@Body() data: any) {\n    // üö® Validation logic\n    if (!data.email || !this.isValidEmail(data.email)) {\n      throw new BadRequestException('Invalid email');\n    }\n\n    // üö® Business logic - checking inventory\n    const product = await this.repository.getProduct(data.productId);\n    if (product.stock < data.quantity) {\n      throw new BadRequestException('Insufficient stock');\n    }\n\n    // üö® Business logic - calculating discount\n    let discount = 0;\n    if (data.quantity > 10) {\n      discount = 0.1;\n    } else if (data.quantity > 5) {\n      discount = 0.05;\n    }\n\n    // üö® Business logic - calculating total\n    const subtotal = product.price * data.quantity;\n    const total = subtotal * (1 - discount);\n\n    // üö® Data access logic\n    const order = await this.repository.save({\n      productId: data.productId,\n      quantity: data.quantity,\n      total,\n    });\n\n    // üö® External service call\n    await this.emailService.sendConfirmation(data.email, order.id);\n\n    return order;\n  }\n\n  private isValidEmail(email: string): boolean {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Single Responsibility - Separate Controller and Service"
  },
  {
    "ruleId": "",
    "ruleTitle": "Single Responsibility - Separate Controller and Service",
    "type": "good",
    "code": "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                   Controller Layer                   ‚îÇ\n‚îÇ  - Parse HTTP requests                               ‚îÇ\n‚îÇ  - Validate with DTOs                                ‚îÇ\n‚îÇ  - Set status codes and headers                      ‚îÇ\n‚îÇ  - Delegate to services                              ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                         ‚îÇ\n                         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                    Service Layer                     ‚îÇ\n‚îÇ  - Execute business logic                            ‚îÇ\n‚îÇ  - Enforce business rules                            ‚îÇ\n‚îÇ  - Coordinate multiple repositories                  ‚îÇ\n‚îÇ  - Emit domain events                                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                         ‚îÇ\n                         ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                  Repository Layer                    ‚îÇ\n‚îÇ  - Data access                                       ‚îÇ\n‚îÇ  - Database queries                                  ‚îÇ\n‚îÇ  - Entity persistence                                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò",
    "language": "typescript",
    "description": "Correct example for Single Responsibility - Separate Controller and Service"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Custom Decorators for Type-Safe Request Data Access",
    "type": "bad",
    "code": "// tasks/tasks.controller.ts - Verbose and unsafe üö®\nimport { Controller, Get, Req, Request } from '@nestjs/common';\nimport { TasksService } from './tasks.service';\n\n@Controller('tasks')\nexport class TasksController {\n  constructor(private tasksService: TasksService) {}\n\n  // ‚ùå Manual extraction with type assertion\n  @Get()\n  findAll(@Req() req: Request) {\n    const user = req.user as any; // ‚ùå Type assertion unsafe\n    return this.tasksService.getTasks(user.id);\n  }\n\n  // ‚ùå Verbose, repeated extraction logic\n  @Get(':id')\n  findOne(@Param('id') id: string, @Req() req: Request) {\n    const user = req.user as User; // ‚ùå Repeated in every method\n    return this.tasksService.findOne(id, user.id);\n  }\n\n  // ‚ùå Type assertion everywhere\n  @Post()\n  create(@Body() dto: CreateTaskDto, @Req() req: Request) {\n    const user = req.user as User;\n    return this.tasksService.create(dto, user.id);\n  }\n\n  // ‚ùå No autocomplete, no type safety\n  @Patch(':id')\n  update(\n    @Param('id') id: string,\n    @Body() dto: UpdateTaskDto,\n    @Req() req: Request,\n  ) {\n    const user = req.user as User;\n    // Does user.id exist? TypeScript doesn't know\n    return this.tasksService.update(id, dto, user.id);\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Custom Decorators for Type-Safe Request Data Access"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Custom Decorators for Type-Safe Request Data Access",
    "type": "good",
    "code": "// auth/decorators/get-user.decorator.spec.ts ‚úÖ\nimport { GetUser } from './get-user.decorator';\nimport { ExecutionContext } from '@nestjs/common';\n\ndescribe('GetUser Decorator', () => {\n  it('should extract user from request', () => {\n    const mockContext = {\n      switchToHttp: () => ({\n        getRequest: () => ({\n          user: { id: '123', email: 'test@example.com' },\n        }),\n      }),\n    } as unknown as ExecutionContext;\n\n    const result = GetUser(null, mockContext);\n\n    expect(result).toEqual({ id: '123', email: 'test@example.com' });\n  });\n\n  it('should extract specific property from user', () => {\n    const mockContext = {\n      switchToHttp: () => ({\n        getRequest: () => ({\n          user: { id: '123', email: 'test@example.com' },\n        }),\n      }),\n    } as unknown as ExecutionContext;\n\n    const result = GetUser('email', mockContext);\n\n    expect(result).toBe('test@example.com');\n  });\n});",
    "language": "typescript",
    "description": "Correct example for Use Custom Decorators for Type-Safe Request Data Access"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Bun's Built-in Crypto for Secure Password Hashing",
    "type": "bad",
    "code": "// auth/auth.service.ts - Insecure üö®\nimport { Injectable } from '@nestjs/common';\nimport { createHash, randomBytes } from 'crypto';\n\n@Injectable()\nexport class AuthService {\n  // ‚ùå Plain text storage\n  async register(email: string, password: string) {\n    return this.prisma.user.create({\n      data: { email, password },  // ‚ùå Stored as-is!\n    });\n  }\n\n  // ‚ùå Fast hash (SHA256, MD5) - crackable with GPUs\n  async hashPassword(password: string) {\n    return createHash('sha256').update(password).digest('hex');\n  }\n\n  // ‚ùå Manual salt - still vulnerable to GPU cracking\n  async hashWithSalt(password: string) {\n    const salt = randomBytes(16).toString('hex');\n    const hash = createHash('sha512')\n      .update(password + salt)\n      .digest('hex');\n    return `${salt}:${hash}`;\n  }\n\n  // ‚ùå Timing-sensitive string comparison\n  async verifyPassword(password: string, hash: string) {\n    const [salt, originalHash] = hash.split(':');\n    const computedHash = createHash('sha512')\n      .update(password + salt)\n      .digest('hex');\n    return computedHash === originalHash;  // ‚ùå Timing attack vulnerable\n  }\n\n  // ‚ùå Weak password requirements\n  @MinLength(6)  // ‚ùå Too short!\n  password: string;\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Bun's Built-in Crypto for Secure Password Hashing"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Bun's Built-in Crypto for Secure Password Hashing",
    "type": "good",
    "code": "// ‚úÖ Recommended for new applications\nasync hash(password: string) {\n  return Bun.password.hash(password);  // Uses argon2id by default\n}\n\n// Or explicitly\nasync hash(password: string) {\n  return Bun.password.hash(password, {\n    algorithm: 'argon2id',\n    memoryCost: 16,  // MB of memory (higher = more GPU-resistant)\n    timeCost: 2,     // Number of iterations\n  });\n}",
    "language": "typescript",
    "description": "Correct example for Use Bun's Built-in Crypto for Secure Password Hashing"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Guards for Route Protection",
    "type": "bad",
    "code": "// users.controller.ts - All routes exposed üö®\n@Controller('users')\nexport class UsersController {\n  @Get()\n  findAll() {\n    return this.usersService.findAll();  // üö® Publicly accessible!\n  }\n\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    return this.usersService.findOne(id);  // üö® Anyone can view any user!\n  }\n\n  @Delete(':id')\n  remove(@Param('id') id: string) {\n    return this.usersService.remove(id);  // üö® Anyone can delete users!\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Guards for Route Protection"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Guards for Route Protection",
    "type": "good",
    "code": "// First install: bun add @nestjs/throttler\n\n// app.module.ts\nimport { ThrottlerModule } from '@nestjs/throttler';\n\n@Module({\n  imports: [\n    ThrottlerModule.forRoot([{\n      ttl: 60000,      // 1 minute\n      limit: 5,        // 5 requests per minute\n    }]),\n  ],\n})\nexport class AppModule {}\n\n// auth/auth.controller.ts\nimport { Throttle } from '@nestjs/throttler';\n\n@Controller('auth')\nexport class AuthController {\n  @Post('login')\n  @Throttle({ default: { limit: 5, ttl: 60000 } })  // ‚úÖ Stricter for login\n  login(@Body() dto: LoginDto) {\n    return this.authService.login(dto);\n  }\n\n  @Post('register')\n  @Throttle({ default: { limit: 3, ttl: 3600000 } })  // ‚úÖ 3 per hour\n  register(@Body() dto: RegisterDto) {\n    return this.authService.register(dto);\n  }\n}",
    "language": "typescript",
    "description": "Correct example for Use Guards for Route Protection"
  },
  {
    "ruleId": "",
    "ruleTitle": "Never Hardcode Secrets - Use Environment Variables",
    "type": "bad",
    "code": "// database.module.ts\nTypeOrmModule.forRoot({\n  url: 'postgres://user:password@localhost/db',  // üö® Exposed!\n  ssl: {\n    cert: process.env.DB_CERT,  // Still vulnerable if cert is committed\n  },\n})\n\n// auth.service.ts\n@Injectable()\nexport class AuthService {\n  private readonly jwtSecret = 'my-super-secret-key-12345';  // üö® Exposed!\n  private readonly apiKey = 'sk_test_abc123xyz';  // üö® Exposed!\n}\n\n// payment.controller.ts\nconst stripe = require('stripe')('sk_test_51ABC...');  // üö® Exposed!",
    "language": "typescript",
    "description": "Incorrect example for Never Hardcode Secrets - Use Environment Variables"
  },
  {
    "ruleId": "",
    "ruleTitle": "Never Hardcode Secrets - Use Environment Variables",
    "type": "good",
    "code": "// For production, ignore .env files and use process.env only\nConfigModule.forRoot({\n  isGlobal: true,\n  ignoreEnvFile: process.env.NODE_ENV === 'production',\n  validationSchema: productionValidationSchema,\n})",
    "language": "typescript",
    "description": "Correct example for Never Hardcode Secrets - Use Environment Variables"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Parameterized Queries to Prevent SQL Injection",
    "type": "bad",
    "code": "// users.service.ts - DANGEROUS üö®\n\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from './prisma.service';\n\n@Injectable()\nexport class UsersService {\n  constructor(private prisma: PrismaService) {}\n\n  // ‚ùå String concatenation - SQL INJECTION\n  async findByName(name: string) {\n    const query = `SELECT * FROM users WHERE name = '${name}'`;\n    return this.prisma.$queryRawUnsafe(query);\n  }\n\n  // ‚ùå Template literal concatenation - VULNERABLE\n  async findByEmailAndPassword(email: string, password: string) {\n    const query = `SELECT * FROM users WHERE email = '${email}' AND password = '${password}'`;\n    return this.prisma.$executeRawUnsafe(query);\n  }\n\n  // ‚ùå Direct interpolation - VULNERABLE\n  async searchUsers(searchTerm: string) {\n    return this.prisma.$queryRaw(\n      `SELECT * FROM users WHERE name LIKE '%${searchTerm}%'`\n    );\n  }\n\n  // ‚ùå Old Prisma syntax (pre-v7)\n  async oldTransactionPattern(userData: any, postData: any) {\n    return this.prisma.$transaction([\n      this.prisma.user.create({ data: userData }),\n      this.prisma.post.create({ data: postData }),\n    ]);\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Parameterized Queries to Prevent SQL Injection"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Parameterized Queries to Prevent SQL Injection",
    "type": "good",
    "code": "// Extended client with custom methods\nconst prisma = new PrismaClient().$extends({\n  model: {\n    user: {\n      async findByEmail(email: string) {\n        return prisma.user.findUnique({ where: { email } });\n      },\n      async findActive() {\n        return prisma.user.findMany({ where: { status: 'ACTIVE' } });\n      },\n    },\n    order: {\n      async calculateTotal(orderId: string) {\n        const items = await prisma.orderItem.findMany({\n          where: { orderId },\n        });\n        return items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n      },\n    },\n  },\n});\n\n// Usage\nconst user = await prisma.user.findByEmail('user@example.com');\nconst total = await prisma.order.calculateTotal('order-123');",
    "language": "typescript",
    "description": "Correct example for Use Parameterized Queries to Prevent SQL Injection"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Custom Repository Pattern for Database Logic Encapsulation",
    "type": "bad",
    "code": "// tasks/tasks.service.ts - Database logic in service üö®\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Task } from './task.entity';\nimport { GetTasksFilterDto } from './dto/get-tasks-filter.dto';\nimport { User } from '../auth/entities/user.entity';\n\n@Injectable()\nexport class TasksService {\n  constructor(\n    @InjectRepository(Task) // ‚ùå Direct repository injection\n    private repo: Repository<Task>\n  ) {}\n\n  async getTasks(filterDto: GetTasksFilterDto, user: User) {\n    const { status, search } = filterDto;\n\n    // ‚ùå Database query logic in service\n    const query = this.repo.createQueryBuilder('task');\n    query.where({ user });\n\n    if (status) {\n      query.andWhere('task.status = :status', { status });\n    }\n\n    if (search) {\n      query.andWhere('(task.title LIKE :search OR task.description LIKE :search)', {\n        search: `%${search}%`,\n      });\n    }\n\n    return await query.getMany();\n  }\n\n  async findOne(id: string, user: User) {\n    // ‚ùå Repeated query logic\n    return this.repo.findOne({ where: { id, user } });\n  }\n\n  async create(dto: CreateTaskDto, user: User) {\n    // ‚ùå Mixed business and data logic\n    const task = this.repo.create({ ...dto, user });\n    return this.repo.save(task);\n  }\n\n  async findOverdue(user: User) {\n    // ‚ùå Complex query in service - hard to test\n    return this.repo\n      .createQueryBuilder('task')\n      .where('task.user = :user', { user })\n      .andWhere('task.dueDate < :now', { now: new Date() })\n      .andWhere('task.status != :status', { status: TaskStatus.DONE })\n      .getMany();\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Custom Repository Pattern for Database Logic Encapsulation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Custom Repository Pattern for Database Logic Encapsulation",
    "type": "good",
    "code": "// For TypeORM >= 0.3, @EntityRepository() decorator is deprecated\n// Use dataSource-based approach:\n\n// tasks/repositories/tasks.repository.ts ‚úÖ\nimport { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectDataSource } from '@nestjs/typeorm';\nimport { DataSource, Repository } from 'typeorm';\nimport { Task } from '../entities/task.entity';\n\n@Injectable()\nexport class TasksRepository {\n  private get repo(): Repository<Task> {\n    return this.dataSource.getRepository(Task);\n  }\n\n  constructor(@InjectDataSource() private dataSource: DataSource) {}\n\n  async getTasks(user: User): Promise<Task[]> {\n    return this.repo.find({ where: { user } });\n  }\n\n  async findOne(id: string, user: User): Promise<Task> {\n    const task = await this.repo.findOne({ where: { id, user } });\n    if (!task) {\n      throw new NotFoundException();\n    }\n    return task;\n  }\n}\n\n// Or use the new TypeOrmEx decorator approach:\n// common/decorators/typeorm-ex.decorator.ts ‚úÖ\nimport { DataSource } from 'typeorm';\nimport { TYPEORM_EX_DATA_SOURCE } from './typeorm-ex.constants';\n\nexport const TypeormExRepository = <T>(entity: Type<any>) =>\n  InjectDataSource(TYPEORM_EX_DATA_SOURCE);\n\n// tasks/repositories/tasks.repository.ts\n@Injectable()\nexport class TasksRepository {\n  constructor(\n    @TypeormExRepository(Task)\n    private dataSource: DataSource,\n  ) {\n    // Use dataSource.getRepository(Task)\n  }\n}",
    "language": "typescript",
    "description": "Correct example for Use Custom Repository Pattern for Database Logic Encapsulation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Implement Health Check Endpoints",
    "type": "bad",
    "code": "// No health endpoint - can't detect failures üö®",
    "language": "typescript",
    "description": "no monitoring"
  },
  {
    "ruleId": "",
    "ruleTitle": "Implement Health Check Endpoints",
    "type": "good",
    "code": "// health.controller.ts\n@Controller('health')\nexport class HealthController {\n  constructor(\n    @Inject(PrismaService) private prisma: PrismaService,\n    @Inject(CacheService) private cache: CacheService,\n  ) {}\n\n  @Get()\n  async checkHealth() {\n    // Database check\n    await this.prisma.$queryRaw`SELECT 1`;\n    \n    // Cache check\n    await this.cache.get('health-check');\n    \n    return {\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      services: { database: 'ok', cache: 'ok' }\n    };\n  }\n}\n\n// main.ts\napp.setGlobalPrefix('api');\napp.use('/api/health', healthRouter);",
    "language": "typescript",
    "description": "comprehensive health checks"
  },
  {
    "ruleId": "",
    "ruleTitle": "Enable Global Exception Filter",
    "type": "bad",
    "code": "// main.ts\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  await app.listen(3000);\n}\n\n// Service throws raw errors\n@Injectable()\nexport class UsersService {\n  async findOne(id: string) {\n    const user = await this.repository.findOne(id);\n    if (!user) {\n      // üö® Throws raw Error - leaks database info\n      throw new Error(`User ${id} not found in database`);\n    }\n    return user;\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Enable Global Exception Filter"
  },
  {
    "ruleId": "",
    "ruleTitle": "Enable Global Exception Filter",
    "type": "good",
    "code": "// common/filters/all-exceptions.filter.ts\nimport { LoggerService } from '../services/logger.service';\n\n@Catch()\nexport class AllExceptionsFilter implements ExceptionFilter {\n  constructor(\n    private configService: ConfigService,\n    private loggerService: LoggerService,\n  ) {}\n\n  catch(exception: unknown, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse();\n    const request = ctx.getResponse();\n\n    const status =\n      exception instanceof HttpException\n        ? exception.getStatus()\n        : HttpStatus.INTERNAL_SERVER_ERROR;\n\n    // ‚úÖ Log to external service (Sentry, DataDog, etc.)\n    this.loggerService.logError({\n      status,\n      path: request.url,\n      method: request.method,\n      exception,\n      userId: request.user?.id,\n      correlationId: request.headers['x-correlation-id'],\n    });\n\n    const errorResponse = this.buildErrorResponse(exception, request);\n    response.status(status).json(errorResponse);\n  }\n}",
    "language": "typescript",
    "description": "Correct example for Enable Global Exception Filter"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Logger with Module Context for Debugging",
    "type": "bad",
    "code": "// tasks/tasks.service.ts - Console logging üö®\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class TasksService {\n  constructor(private tasksRepository: TasksRepository) {}\n\n  // ‚ùå Console.log - no context, no levels\n  async createTask(dto: CreateTaskDto, user: User) {\n    console.log('Creating task'); // ‚ùå No module context\n    const task = await this.tasksRepository.create(dto, user);\n    console.log('Task created:', task); // ‚ùå No structure\n    return task;\n  }\n\n  // ‚ùå Console.error for errors\n  async deleteTask(id: string) {\n    try {\n      return await this.tasksRepository.delete(id);\n    } catch (error) {\n      console.error('Error deleting task:', error); // ‚ùå No context\n      throw error;\n    }\n  }\n\n  // ‚ùå No logging at all\n  async updateTask(id: string, dto: UpdateTaskDto) {\n    return this.tasksRepository.update(id, dto); // ‚ùå Silent operation\n  }\n}\n\n// tasks/tasks.controller.ts - No logging üö®\nimport { Controller, Get, Post, Body } from '@nestjs/common';\n\n@Controller('tasks')\nexport class TasksController {\n  @Get()\n  findAll(@Query() filterDto: GetTasksFilterDto) {\n    // ‚ùå No logging - hard to debug in production\n    return this.tasksService.findAll(filterDto);\n  }\n\n  @Post()\n  create(@Body() dto: CreateTaskDto) {\n    // ‚ùå No audit trail\n    return this.tasksService.create(dto);\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Logger with Module Context for Debugging"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Logger with Module Context for Debugging",
    "type": "good",
    "code": "// ‚úÖ Add request ID to all logs in a request\n// common/middleware/request-id.middleware.ts\nimport { Injectable, NestMiddleware, Logger } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport { v4 as uuidv4 } from 'uuid';\n\n@Injectable()\nexport class RequestIdMiddleware implements NestMiddleware {\n  private logger = new Logger(RequestIdMiddleware.name);\n\n  use(req: Request, res: Response, next: NextFunction) {\n    const id = uuidv4();\n    req['id'] = id;\n\n    // ‚úÖ Add request ID to response header\n    res.setHeader('X-Request-ID', id);\n\n    this.logger.verbose(`[${id}] ${req.method} ${req.url}`);\n\n    next();\n  }\n}\n\n// tasks/tasks.service.ts - Use request ID ‚úÖ\nimport { Injectable, Logger, Scope } from '@nestjs/common';\n\n@Injectable({ scope: Scope.REQUEST })\nexport class TasksService {\n  private readonly logger = new Logger(TasksService.name);\n\n  constructor(@Inject(REQUEST) private request: Request) {\n    // ‚úÖ Use request ID in logs\n    const requestId = request['id'];\n    if (requestId) {\n      this.logger.setContext(`[${requestId}] ${TasksService.name}`);\n    }\n  }\n\n  findAll() {\n    this.logger.log('Retrieving all tasks');\n    // Output: [abc-123] [TasksService] Retrieving all tasks\n    return this.tasksRepository.findAll();\n  }\n}",
    "language": "typescript",
    "description": "Correct example for Use Logger with Module Context for Debugging"
  },
  {
    "ruleId": "",
    "ruleTitle": "Implement Proper Logging Strategy",
    "type": "bad",
    "code": "// users.service.ts - No structure üö®\nconsole.log('Creating user:', data);\ntry {\n  const user = await this.prisma.user.create({ data });\n  console.log('User created:', user.id);\n} catch (error) {\n  console.error('User creation failed:', error);\n}",
    "language": "typescript",
    "description": "console.log debugging"
  },
  {
    "ruleId": "",
    "ruleTitle": "Implement Proper Logging Strategy",
    "type": "good",
    "code": "// logger.service.ts\nimport { LoggerService } from '@nestjs/common';\nimport * as winston from 'winston';\n\n@Injectable()\nexport class WinstonLogger implements LoggerService {\n  private logger = winston.createLogger({\n    level: 'info',\n    format: winston.format.combine(\n      winston.format.timestamp(),\n      winston.format.json()\n    ),\n    transports: [\n      new winston.transports.Console(),\n      new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),\n    ],\n  });\n}\n\n// users.service.ts\nimport { Logger } from '@nestjs/common';\n\n@Injectable()\nexport class UsersService {\n  private readonly logger = new Logger(UsersService.name);\n\n  async createUser(data: CreateUserDto) {\n    this.logger.log(`Creating user for email: ${data.email}`, 'UsersService');\n    \n    try {\n      const user = await this.prisma.user.create({ data });\n      this.logger.log(`User created successfully: ${user.id}`);\n      return user;\n    } catch (error) {\n      this.logger.error(`Failed to create user ${data.email}: ${error.message}`, error.stack);\n      throw error;\n    }\n  }\n}",
    "language": "typescript",
    "description": "structured logging"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Response Transformation Interceptor for Serialization",
    "type": "bad",
    "code": "// users/users.controller.ts - Leaks sensitive data üö®\nimport { Controller, Get, Param } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\n@Controller('users')\nexport class UsersController {\n  constructor(private usersService: UsersService) {}\n\n  // ‚ùå Returns entity with password field\n  @Get(':id')\n  async findOne(@Param('id') id: string) {\n    const user = await this.usersService.findOne(id);\n    // Response includes: { id, email, name, password, internalNotes }\n    // Password is exposed!\n    return user;\n  }\n\n  // ‚ùå Returns raw repository data\n  @Get()\n  async findAll() {\n    // Returns all users with all fields\n    return this.usersService.findAll();\n  }\n\n  // ‚ùå Manual exclusion - verbose and error-prone\n  @Get('public/:id')\n  async findPublic(@Param('id') id: string) {\n    const user = await this.usersService.findOne(id);\n    // ‚ùå Must remember to exclude in every method\n    const { password, internalNotes, ...publicUser } = user;\n    return publicUser;\n  }\n}\n\n// users/entities/user.entity.ts - No exclusion decorators üö®\nimport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column()\n  email: string;\n\n  @Column()\n  password: string;  // ‚ùå Will be included in all responses\n\n  @Column({ name: 'internal_notes' })\n  internalNotes: string;  // ‚ùå Leaked to clients\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Response Transformation Interceptor for Serialization"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Response Transformation Interceptor for Serialization",
    "type": "good",
    "code": "// ‚úÖ Interceptor that handles arrays, pagination, etc.\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { map, Observable } from 'rxjs';\nimport { instanceToPlain } from 'class-transformer';\n\n@Injectable()\nexport class TransformInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    return next.handle().pipe(\n      map((data) => {\n        // Handle Pagination\n        if (data?.data !== undefined && data?.meta !== undefined) {\n          return {\n            ...data,\n            data: instanceToPlain(data.data),\n          };\n        }\n\n        // Handle Arrays\n        if (Array.isArray(data)) {\n          return data.map((item) => instanceToPlain(item));\n        }\n\n        // Handle single objects\n        return instanceToPlain(data);\n      }),\n    );\n  }\n}",
    "language": "typescript",
    "description": "Correct example for Use Response Transformation Interceptor for Serialization"
  },
  {
    "ruleId": "",
    "ruleTitle": "Enable Compression Middleware for Responses",
    "type": "bad",
    "code": "// main.ts - Large responses üö®\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  await app.listen(3000);\n}",
    "language": "typescript",
    "description": "no compression"
  },
  {
    "ruleId": "",
    "ruleTitle": "Enable Compression Middleware for Responses",
    "type": "good",
    "code": "// main.ts\nimport * as compression from 'compression';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.use(compression());  // Gzip/brotli compression ‚úÖ\n  await app.listen(3000);\n}",
    "language": "typescript",
    "description": "compressed responses"
  },
  {
    "ruleId": "",
    "ruleTitle": "Implement Rate Limiting for All Routes",
    "type": "bad",
    "code": "// main.ts - Unlimited requests üö®\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  await app.listen(3000);\n}",
    "language": "typescript",
    "description": "no protection"
  },
  {
    "ruleId": "",
    "ruleTitle": "Implement Rate Limiting for All Routes",
    "type": "good",
    "code": "// main.ts\nimport { ThrottlerModule, ThrottlerGuard } from '@nestjs/throttler';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  app.useGlobalGuards(new ThrottlerGuard());\n  \n  await app.listen(3000);\n}\n\n// app.module.ts\n@Module({\n  imports: [\n    ThrottlerModule.forRoot([{\n      ttl: 60,        // 60 seconds\n      limit: 10,      // 10 requests per IP\n    }]),\n  ],\n})",
    "language": "typescript",
    "description": "rate limited"
  },
  {
    "ruleId": "",
    "ruleTitle": "Cache Frequently Used Data with Redis",
    "type": "bad",
    "code": "// users.service.ts - DB hit every time üö®\nasync getUserProfile(id: string) {\n  return this.prisma.user.findUnique({\n    where: { id },\n    include: { posts: true, followers: true }\n  });\n}",
    "language": "typescript",
    "description": "database every request"
  },
  {
    "ruleId": "",
    "ruleTitle": "Cache Frequently Used Data with Redis",
    "type": "good",
    "code": "// cache.service.ts\n@Injectable()\nexport class CacheService {\n  constructor(private redis: Redis) {}\n  \n  async get<T>(key: string): Promise<T | null> {\n    const data = await this.redis.get(key);\n    return data ? JSON.parse(data) : null;\n  }\n  \n  async set(key: string, data: any, ttl = 300) {\n    await this.redis.setex(key, ttl, JSON.stringify(data));\n  }\n}\n\n// users.service.ts\nasync getUserProfile(id: string) {\n  const cacheKey = `user:${id}:profile`;\n  let profile = await this.cacheService.get(cacheKey);\n  \n  if (!profile) {\n    profile = await this.prisma.user.findUnique({\n      where: { id },\n      include: { posts: true, followers: true }\n    });\n    await this.cacheService.set(cacheKey, profile, 300);  // 5min ‚úÖ\n  }\n  \n  return profile;\n}",
    "language": "typescript",
    "description": "Redis cached"
  },
  {
    "ruleId": "",
    "ruleTitle": "Enable CORS with Whitelist Origins Only",
    "type": "bad",
    "code": "// main.ts\napp.enableCors();  // Uses '*' - dangerous! üö®",
    "language": "typescript",
    "description": "vulnerable CORS"
  },
  {
    "ruleId": "",
    "ruleTitle": "Enable CORS with Whitelist Origins Only",
    "type": "good",
    "code": "// main.ts\napp.enableCors({\n  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['https://yourapp.com'],\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n});",
    "language": "typescript",
    "description": "secure CORS"
  },
  {
    "ruleId": "",
    "ruleTitle": "Regular Dependency Security Audits",
    "type": "bad",
    "code": "// package.json - outdated packages üö®\n{\n  \"dependencies\": {\n    \"lodash\": \"^4.17.20\",  // CVE-2021-23337\n    \"express\": \"^4.17.1\"    // Multiple CVEs\n  }\n}",
    "language": "json",
    "description": "vulnerable deps"
  },
  {
    "ruleId": "",
    "ruleTitle": "Regular Dependency Security Audits",
    "type": "good",
    "code": "# Pre-commit / CI checks\nbun run audit:check\nnpm audit --audit-level high\nbun pm audit           # Bun's audit check\nsnyk test --severity-threshold=high",
    "language": "bash",
    "description": "automated security"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Helmet Middleware for Security Headers",
    "type": "bad",
    "code": "// main.ts\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  // Define routes before helmet - insecure!\n  app.route('/api', ...);\n\n  app.use(helmet());\n  await app.listen(3000);\n}",
    "language": "typescript",
    "description": "vulnerable headers"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Helmet Middleware for Security Headers",
    "type": "good",
    "code": "// main.ts\nimport helmet from 'helmet';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  // Apply helmet FIRST, before routes and other middleware\n  app.use(helmet());\n\n  // Now define routes\n  app.route('/api', ...);\n\n  await app.listen(3000);\n}",
    "language": "typescript",
    "description": "Express"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Helmet Middleware for Security Headers",
    "type": "good",
    "code": "// main.ts\nimport helmet from '@fastify/helmet';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  // Fastify uses register() instead of use()\n  await app.register(helmet);\n\n  await app.listen(3000);\n}",
    "language": "typescript",
    "description": "Fastify"
  },
  {
    "ruleId": "",
    "ruleTitle": "Write Comprehensive Unit Tests",
    "type": "bad",
    "code": "// users.service.ts - No tests üö®\n@Injectable()\nexport class UsersService {\n  async createUser(data: CreateUserDto) {\n    return this.prisma.user.create({ data });\n  }\n}",
    "language": "typescript",
    "description": "no tests"
  },
  {
    "ruleId": "",
    "ruleTitle": "Write Comprehensive Unit Tests",
    "type": "good",
    "code": "// users.service.spec.ts\ndescribe('UsersService', () => {\n  let service: UsersService;\n  let prisma: PrismaService;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [UsersService, { provide: PrismaService, useValue: mockPrisma }],\n    }).compile();\n    service = module.get(UsersService);\n  });\n\n  it('should create user successfully', async () => {\n    const dto: CreateUserDto = { email: 'test@example.com', name: 'Test' };\n    const mockUser = { id: '1', ...dto };\n\n    jest.spyOn(prisma.user, 'create').mockResolvedValue(mockUser);\n\n    const result = await service.createUser(dto);\n    expect(result).toEqual(mockUser);\n    expect(prisma.user.create).toHaveBeenCalledWith(expect.any(Object));\n  });\n});",
    "language": "typescript",
    "description": "full test suite"
  },
  {
    "ruleId": "",
    "ruleTitle": "Create Custom Pipes for Query Parameter Transformation",
    "type": "bad",
    "code": "// users.controller.ts - Manual type conversion üö®\n@Controller('users')\nexport class UsersController {\n  @Get()\n  async findAll(@Query() query: any) {\n    // ‚ùå Manual parsing - error-prone\n    const page = parseInt(query.page as string, 10) || 1;\n    const limit = parseInt(query.limit as string, 10) || 10;\n\n    // ‚ùå Manual boolean conversion\n    const active = query.active === 'true' || query.active === '1';\n\n    // ‚ùå Manual trimming\n    const search = query.search ? (query.search as string).trim() : undefined;\n\n    // ‚ùå No validation - NaN possible\n    if (isNaN(page) || isNaN(limit)) {\n      throw new BadRequestException('Invalid page or limit');\n    }\n\n    return this.usersService.findAll({ page, limit, active, search });\n  }\n\n  @Get(':id')\n  async findOne(@Param('id') id: string) {\n    // ‚ùå Manual integer conversion\n    const userId = parseInt(id, 10);\n    if (isNaN(userId)) {\n      throw new BadRequestException('Invalid user ID');\n    }\n    return this.usersService.findOne(userId);\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Create Custom Pipes for Query Parameter Transformation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Create Custom Pipes for Query Parameter Transformation",
    "type": "good",
    "code": "// common/pipes/parse-int.pipe.spec.ts ‚úÖ\nimport { ParseIntPipe } from './parse-int.pipe';\nimport { BadRequestException } from '@nestjs/common';\n\ndescribe('ParseIntPipe', () => {\n  let pipe: ParseIntPipe;\n\n  beforeEach(() => {\n    pipe = new ParseIntPipe();\n  });\n\n  it('should parse valid integer string', () => {\n    const result = pipe.transform('42', { type: 'query', data: 'page' } as any);\n    expect(result).toBe(42);\n  });\n\n  it('should throw for invalid string', () => {\n    expect(() => pipe.transform('abc', { type: 'query', data: 'page' } as any))\n      .toThrow(BadRequestException);\n  });\n\n  it('should return undefined for optional empty value', () => {\n    const optionalPipe = new ParseIntPipe({ optional: true });\n    const result = optionalPipe.transform('', { type: 'query', data: 'page' } as any);\n    expect(result).toBeUndefined();\n  });\n\n  it('should enforce min value', () => {\n    const pipeWithMin = new ParseIntPipe({ minValue: 1 });\n    expect(() => pipeWithMin.transform('0', { type: 'query', data: 'page' } as any))\n      .toThrow(BadRequestException);\n  });\n\n  it('should enforce max value', () => {\n    const pipeWithMax = new ParseIntPipe({ maxValue: 100 });\n    expect(() => pipeWithMax.transform('101', { type: 'query', data: 'page' } as any))\n      .toThrow(BadRequestException);\n  });\n});",
    "language": "typescript",
    "description": "Correct example for Create Custom Pipes for Query Parameter Transformation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Validate All Inputs with DTOs and ValidationPipe",
    "type": "bad",
    "code": "// main.ts - Missing ValidationPipe\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  await app.listen(3000);  // No global pipe!\n}\n\n// users.controller.ts - No validation\n@Post()\ncreate(@Body() createUserDto: any) {\n  // Any data can be passed - vulnerable!\n  return this.usersService.create(createUserDto);\n}\n\n// dto/create-user.dto.ts - No decorators\nexport class CreateUserDto {\n  email: string;      // No validation\n  password: string;   // No validation\n  age: number;        // No validation\n}",
    "language": "typescript",
    "description": "Incorrect example for Validate All Inputs with DTOs and ValidationPipe"
  },
  {
    "ruleId": "",
    "ruleTitle": "Validate All Inputs with DTOs and ValidationPipe",
    "type": "good",
    "code": "{\n  \"statusCode\": 400,\n  \"message\": [\n    \"email must be an email\",\n    \"password must be longer than or equal to 8 characters\",\n    \"password must contain uppercase, lowercase, and number\",\n    \"age must not be less than 18\"\n  ],\n  \"error\": \"Bad Request\"\n}",
    "language": "json",
    "description": "Correct example for Validate All Inputs with DTOs and ValidationPipe"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Filter DTOs for Query Parameter Validation",
    "type": "bad",
    "code": "// tasks/tasks.controller.ts - Individual parameters üö®\nimport { Controller, Get, Query } from '@nestjs/common';\n\n@Controller('tasks')\nexport class TasksController {\n  @Get()\n  findAll(\n    @Query('status') status: string,        // ‚ùå No validation\n    @Query('search') search: string,        // ‚ùå No validation\n    @Query('page') page: string,            // ‚ùå String, not number\n    @Query('limit') limit: string,          // ‚ùå String, not number\n  ) {\n    // ‚ùå Manual type conversion\n    const pageNum = parseInt(page) || 1;\n    const limitNum = parseInt(limit) || 10;\n\n    // ‚ùå No type safety - status could be \"INVALID\"\n    return this.tasksService.getTasks(status, search, pageNum, limitNum);\n  }\n\n  @Get()\n  findAll(@Query() query: any) {\n    // ‚ùå No type safety at all\n    const status = query.status as string;\n    const page = parseInt(query.page) || 1;\n    const limit = parseInt(query.limit) || 10;\n    const search = query.search;\n\n    return this.tasksService.getTasks(status, search, page, limit);\n  }\n}\n\n// tasks/tasks.service.ts üö®\n@Injectable()\nexport class TasksService {\n  // ‚ùå Too many parameters, no type safety\n  async getTasks(\n    status: string | undefined,\n    search: string | undefined,\n    page: number,\n    limit: number,\n  ) {\n    // ‚ùå What values are valid for status? No hints.\n    const query = this.repo.createQueryBuilder('task');\n\n    if (status) {\n      query.andWhere('task.status = :status', { status });\n    }\n\n    if (search) {\n      query.andWhere('(task.title LIKE :search OR task.description LIKE :search)', {\n        search: `%${search}%`,\n      });\n    }\n\n    query.skip((page - 1) * limit).take(limit);\n\n    return query.getMany();\n  }\n}",
    "language": "typescript",
    "description": "Incorrect example for Use Filter DTOs for Query Parameter Validation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Filter DTOs for Query Parameter Validation",
    "type": "good",
    "code": "// ‚úÖ Different validation for different scenarios\n// tasks/dto/get-tasks-filter.dto.ts\nimport { ValidateIf } from 'class-validator';\n\nexport class GetTasksFilterDto {\n  @IsOptional()\n  @IsEnum(TaskStatus)\n  status?: TaskStatus;\n\n  // ‚úÖ Only validate if search is present\n  @IsOptional()\n  @IsString()\n  @MinLength(3, { message: 'Search must be at least 3 characters' })\n  search?: string;\n\n  // ‚úÖ Validate 'from' only if 'to' is also present\n  @IsOptional()\n  @ValidateIf((o) => o.to !== undefined)\n  @IsDate()\n  from?: Date;\n\n  @IsOptional()\n  @ValidateIf((o) => o.from !== undefined)\n  @IsDate()\n  to?: Date;\n}",
    "language": "typescript",
    "description": "Correct example for Use Filter DTOs for Query Parameter Validation"
  }
]